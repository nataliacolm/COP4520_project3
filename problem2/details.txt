Overview:
Different linked lists are used to store information in sorted order for the purpose of retrieving data in sorted order for the reporting. Threads mimic an hour by using the fact that an iteration is a minute and each thread will input 60 temperature readings for the hour, for a total of 480 readings. The current program is set to 20 hours but can be changed by changing the int hours variable in the Temp class. Additionally, every sensor has a name, a digit from 0 to n(number of sensors - 1) to detail what positions in the intervals array list is theirs to add a data point. Therefore, 1 minute intervals are respected as a thread can only have one reading per minute.

Proof of correctness:
My linked list implementation utilizes the range information of -100 to 70F to construct the initial list. This list also allows for duplicates by using a <key, value> structure. In order to add or remove from the list, a thread would search for the key and call an incrementAndGet() or decrementAndGet() on the value portion. Therefore, no synchronization issues will arise when attempting to add or delete at the same time since only the value is atomically incremented or decremented. This also means that the threads will never be delayed since the list already has constructed nodes <-100, 0>...<70,0> for the initialization. Therefore, a thread only has to worry about locating the temperature in the list. 

In order to preserve the order during the 10 minute intervals, an AtomicIntegerArray is created to demonstrate during which iteration of time the 8 sensors added a certain value. In this process, all threads are given a name as an integer that represents the index a thread may use to input their given value. With every iteration, the name is updated to (name = name + number of sensors) so the thread can find the next index to use. This ensures that no thread overlaps when adding to the array list. Therefore, no synchronization issues arise here either and threads are not delayed in this step. Also, main uses the ten_min variable to determine when main can begin processing the 10 minute intervals, ensuring that if 8 threads have completed a new job, then a new minute is ready to be processed for the window, and the old minute must have its data removed from the intervals linked list. The intervals linked list is constantly updated by main after the initial 10 minutes is added by the threads to quickly add and remove old and new data from the threads with the help of the intervals array list (to ensure ordering).

Using progress guarantee of linearizability:
The moment the value gets incremented is the moment all other threads will be able to see the effect. Thus, the linearization point can be said to occur the moment incrementAndGet() is called in the add() function or decrementAndGet() in the remove() function. 

Lastly, the program was run multiple times with different hours to ensure correctness (see runs.txt).

Efficiency:
Threads will not be delayed since we know the range beforehand and threads may add concurrently without the fear of conflicting because only an atomic integer is getting updated. Additionally, this is a doubly linked list, which means it is easy to grab the 5 top temperatures and the lowest 5 temperatures from the hour by starting from head or tail since the doubly linked list is already sorted. Also, when adding to the array list that stores the interval of times that temperature readings were put in, it is not dependent on the state of other threads. Therefore, delays also do not occur when modifying the array list. 

Main also processes the readings while new readings occur, which means threads do not have to wait every time a minute is up for main to process the new readings. Additionally, the 10 minute interval window is processed by using the fact that we do not need to traverse the whole list, but instead just find the valid temperature closest to the head of the list and the tail of the list to find the minimum and maximum at each valid 10 minute interval since data is stored is sorted order in the doubly linked list. For example, if a temperature ever reads 70F in a valid 10 minute interval, retrieval of that data will be constant.

Experimental evaluation:
First attempt involved a lock-free linked list, but after careful evaluation, it worried me that one thread may get delayed if references changed when adding or deleting. Therefore, my next idea was to combine that of a hash map and a sorted linked list. As a result, I took advantage of the fact that the temperatures had a certain range and created the linked list I have implemented in the program right now. In fact, when testing, threads were able to immediately add their temperature readings without an issue. I also decided to have main look for the largest 10 minute interval only after completion (by synchronizing threads every iteration with a count down latch). Overall, execution time for 4 hours was ~6 seconds. 
In order to speed up the process, I decided to have main process the readings every iteration and do calculations while the threads were running to find the largest 10 minute interval. I then decided to use the fact that a doubly linked list may speed up retrieval of min and max since I could start the search at whatever endpoint since the linked list I use to store temperatures was sorted. As a result, execution time ramped up to ~125ms for 20 hours. 