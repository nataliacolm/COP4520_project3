The problem with the Minotaur's first implementation was that the Minotaur did not take into account what could happen if a present was added or removed at the time a present was trying to link itself to the predecessor's link and the next present in the chain when adding, or when a present was being unlinked from its predecessor, and attempting to connect itself with the next gift in the chain when removing. Having more presents than "Thank you" notes was a result of not having some form of validation that checks if the references that we are trying to link with are still valid and unchanged.

Proof of correctness:
A solution to the Minotaur's problem is using a lock-free linked list. Namely, the lock-free linked list found in the textbook in Chapter 9. In this implementation, we logically remove a node before physically removing it. Therefore, validation occurs through a CAS operation when verifying that a node is still reachable (unmarked). If a node is not found or marked, then we assume the node is unreachable.

This implementation numbers presents 0-500,000 and uses that as a unique id. Therefore, we ensure that the chain is saving presents in sorted order. The presents are first added to an array list and then Collections.shuffle is called on it to represent an unordered bag. An atomic integer is then used to represent a current present in the unordered bag that is available to be added to the chain. One thread will add a present to the chain by calling getAndIncrement() on the index variable and then going to that location. Therefore, servants will never have the same present to add. Additionally, delete follows the same method, using an index from the unordered bag to delete from. Additionally, delete runs in a while loop, ensuring that the delete is successful before attempting to add or delete again. Therefore, writing a "thank you" note is never skipped. 

The program does not terminate until the list is empty, which means in this case, head points to tail. Therefore, it is assured that all thank you notes were properly written.


Efficiency:
There are different possible implementation to solve this problem, including using locks for an optimisitc synchronization implementation or fine grained synchronization. But, locks are not the most efficient method because they might be called multiple times, which may mean that if at any time a servant is delayed, then the other servants may be delayed as well. In order to bypass such an effect, a lock-free linked list is constructed to solve the problem. In fact, progress is guaranteed because if at any time a servant fails in adding or deleting, then it is because another servant was successful.


Experimental evaluation:
First implementation involved using locks to ensure that only one servant could place a present at a time to ensure sorted order. After running the program, it would not stop after ~30 seconds before I had to terminate the program myself. Therefore, another implementation had to be explored. I then decided to try to implement a lock free implementation. This greatly reduced the execution time, with an overall average of ~500ms (see runs.txt). Additionally, in order to verify if sorted order of ids was preserved. I made sure to verify that smaller sets of presents (10, 20, 50) were correctly printed in sorted order and when verifying presents bag size of 500,000 I verified that present 499,999 was the last item in the list without any deletes.
